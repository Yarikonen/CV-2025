# Адаптивная бинаризация изображений

## Теоретическая база

### Адаптивная бинаризация

Адаптивная бинаризация - это метод пороговой обработки изображений, при котором порог вычисляется локально для каждого пикселя на основе характеристик его окрестности. В отличие от глобальной бинаризации, этот подход эффективен для изображений с неравномерным освещением.

### Математическая основа

Для пикселя I(x,y) с координатами (x,y) адаптивный порог T(x,y) вычисляется как:
T(x,y) = μ(x,y) - C

где:
- μ(x,y) - взвешенная сумма значений в окрестности пикселя  
- C - константа (обычно положительная)

### Методы вычисления локального порога

1. Mean (усреднение):
1. Mean (усреднение):
$$
\mu(x,y) = \frac{1}{(2k+1)^2} \sum_{i=-k}^{k} \sum_{j=-k}^{j} I(x+i, y+j)
$$

2. Gaussian (взвешенное усреднение):
$$
\mu(x,y) = \frac{\sum_{i=-k}^{k} \sum_{j=-k}^{k} I(x+i, y+j) \cdot G(i,j)}{\sum_{i=-k}^{k} \sum_{j=-k}^{k} G(i,j)}
$$

где G(i,j) - гауссово ядро

## Описание разработанной системы

### Алгоритмы

Программа реализует два алгоритма адаптивной бинаризации:

1. Mean метод:
- Вычисляет среднее арифметическое в квадратной окрестности
- Прост в реализации и вычислениях

2. Gaussian метод:
- Использует гауссово взвешивание для плавного усреднения
- Более устойчив к шуму

### Архитектура системы
AdaptiveThreshold
├── adaptive_threshold_opencv() # Реализация с OpenCV
├── adaptive_threshold_native_mean() # Нативная mean реализация
└── adaptive_threshold_native_gaussian() # Нативная gaussian реализация

### Принципы работы

1. OpenCV реализация: использует оптимизированные функции cv2.adaptiveThreshold
2. Нативная реализация: поэлементная обработка с циклами Python/NumPy
3. Сравнение: измерение времени выполнения и визуальная оценка качества

## Результаты работы и тестирования

### Пример работы программы
=== РЕЗУЛЬТАТЫ СРАВНЕНИЯ ===

MEAN МЕТОД:
OpenCV время: 0.0012 сек
Нативное время: 1.4567 сек
Ускорение OpenCV: 1213.92x
Разница результатов: 0.0234%

GAUSSIAN МЕТОД:
OpenCV время: 0.0013 сек
Нативное время: 3.8923 сек
Ускорение OpenCV: 2994.08x
Разница результатов: 0.0456%

### Визуальные результаты

![Сравнение результатов](./images/results_comparison.png)

### Анализ производительности

![Анализ производительности](./images/performance_analysis.png)
### Наблюдаемые закономерности

1. OpenCV реализация значительно превосходит нативную по скорости (ускорение более чем в 1000 раз).
2. Gaussian метод более сложен и требует больше времени на выполнение по сравнению с Mean методом.
3. Увеличение размера блока приводит к росту времени выполнения для обеих реализаций.
4. Разница в результатах между OpenCV и нативной реализациями минимальна (менее 0.1%), что подтверждает их корректность.

## Выводы по работе

1. Производительность: OpenCV демонстрирует исключительную эффективность благодаря оптимизированным C++ реализациям и векторным операциям.

2. Точность: Обе реализации дают практически идентичные результаты, что подтверждает корректность алгоритмов.

3. Практическое применение: Для реальных задач рекомендуется использовать OpenCV версию из-за значительно лучшей производительности.

4. Образовательная ценность: Нативная реализация полезна для понимания принципов работы алгоритма, но не подходит для production-систем.

5. Оптимизация: Основные направления оптимизации - векторизация вычислений, использование кэша и параллелизация.

## Использованные источники

1. OpenCV Documentation: Adaptive Thresholding
2. Bradski, G., & Kaehler, A. (2008). Learning OpenCV
3. Gonzalez, R. C., & Woods, R. E. (2018). Digital Image Processing
4. NumPy Documentation: Vectorization techniques
